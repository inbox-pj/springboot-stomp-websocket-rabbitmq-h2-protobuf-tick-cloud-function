#####################################################
# General
spring.application.name = @project.artifactId@
host.name = #{T(java.net.InetAddress).getLocalHost().getHostName()}
# note - instance.id should not contain a random element in prod (we want queue names to remain the same after restarts)
instance.id = ${host.name}.#{T(Math).abs(T(java.util.UUID).randomUUID().hashCode())}
configuration.reload.interval.ms = 60000
reload.legacy.config = true
#spring.main.banner-mode = off
spring.banner.image.location = classpath:bolt.png
spring.banner.image.invert = true
master.api.key = qKHy3SsH5AfTJbP3K1n8tRpEJdlEZ9dTNbxuYi3al1s=
api.key.format.regex = ^[a-zA-Z0-9=/+]+$
active.data.center = true
other.data.center.hostname =
management.server.add-application-context-header = false
# disable checking for spring groovy templates due to terminal emulator dependency on classpath
spring.groovy.template.check-template-location = false
client.connection.ttl.seconds = 30
client.connection.warn.threshold.percent = 0.9
bolt.content.security.policy =
server.http2.enabled=true

#qa test Profile
rest.controller.qa.enabled=false
qa.api.key=
#####################################################
# REST API
server.port = 8080
internal.port = 8082
rest.controller.default.terminal.request.timeout.ms = 5000
rest.controller.default.composite.request.timeout.ms = #{60000 * 5}
rest.controller.terminal.status.request.maximum.limit=50
# ${terminal.service.manual.input.request.timeout.ms} + ${terminal.service.cancel.request.timeout.ms} + 1000
rest.controller.default.manual.input.request.timeout.ms = #{60000 * 2 + 30000 + 1000}
rest.controller.default.cancel.request.timeout.ms = 30500
# The below takes into account the semi-integrated authCard logic, which requires a longer timeout:
#   ${terminal.service.manual.input.request.timeout.ms} + ${terminal.service.(sale|manual.refund).request.timeout.ms} +
#   ${terminal.service.cancel.request.timeout.ms} + 1000
rest.controller.authcard.request.timeout.ms = #{60000 * 2 + 60000 * 4 + 30000 + 1000}
server.servlet.encoding.enabled = true
server.servlet.encoding.charset = UTF-8
server.servlet.encoding.force-request = true
# csv, checked against terminalmerchprops.domain value using String.startsWith
auth.api.disabled.sites = fts
auth.api.status.display.text = \n##status##
auth.api.clear.display.default.delay.ms = 1500
auth.api.post.auth.signature.update.enabled = true
terminal.status.api.send.pings = true
rest.controller.developer.enabled = false
rest.controller.readselection.options.limit = 100
#ttl to be used for hazelcast map entries containing a session as well as couchbase session documents
rest.api.sessionkey.expiration.seconds = #{60 * 10}

#####################################################s
# Hazelcast
hazelcast.request.queue.map.name = requestQueueMap
hazelcast.group.name = bolt-cluster
hazelcast.group.password = bolt-cluster
hazelcast.network.port = 5701
hazelcast.network.port.autoincrement = true
hazelcast.network.join.multicast.enabled = true
hazelcast.network.join.multicast.group = 224.2.2.3
hazelcast.network.join.multicast.port = 54327
hazelcast.network.join.multicast.timeout.seconds = 2
hazelcast.network.join.tcpip.enabled = false
# members should be comma-separated with no spaces
hazelcast.network.join.tcpip.members =
hazelcast.request.queue.processor.threads = 2
hazelcast.response.queue.processor.threads = 2
hazelcast.request.queue.max.size = 10000
hazelcast.response.queue.max.size = 10000
hazelcast.merge.first.run.delay.seconds = 60
hazelcast.merge.next.run.delay.seconds = 60
hazelcast.max.no.heartbeat.seconds = 60
hazelcast.session.map.name = sessionMap
hazelcast.merchant.properties.map.name = merchantPropsMap
hazelcast.cluster.size = 1
hazelcast.active.data.center.map.name = activeDataCenter
hazelcast.download.calls.map.name = downloadCalls
hazelcast.jet.enabled = false

#####################################################s
# Couchbase
couchbase.cluster.connection.string = vfd-cb1data-1.ftscc.net,vfd-cb1data-2.ftscc.net,vfd-cb1data-3.ftscc.net,vfd-cb1data-4.ftscc.net
couchbase.cluster.username = bolt_svc
couchbase.cluster.password = qQVA8xKm9pYnEMC2
couchbase.cluster.bucket.name = bolt
couchbase.env.timeout.connectTimeout.seconds = 10
couchbase.env.timeout.disconnectTimeout.seconds = 10
couchbase.env.timeout.kvTimeout.ms = 500
# circuit breaker defaults taken from https://docs.couchbase.com/java-sdk/current/ref/client-settings.html#circuit-breaker-options
couchbase.env.io.kvCircuitBreaker.enabled = true
couchbase.env.io.kvCircuitBreaker.volumeThreshold = 20
couchbase.env.io.kvCircuitBreaker.errorThresholdPercentage = 50
couchbase.env.io.kvCircuitBreaker.sleepWindow.seconds = 5
couchbase.env.io.kvCircuitBreaker.rollingWindow.minutes = 1
couchbase.health.indicator.enabled = true
couchbase.data.integrity.check.enabled = true

#####################################################
# Terminal Server
panpad.terminal.server.port = 9990
bolt.terminal.server.port = 9991
terminal.server.port = ${panpad.terminal.server.port}
terminal.server.response.map.max.size = 100000
# set to value of longest terminal timeout + 10 seconds (${terminal.service.(sale|manual.refund).request.timeout.ms})
terminal.server.response.map.expiration.ms = #{(60000 * 4) + 10000}
terminal.server.client.response.map.max.size = 100000
# set to value of longest web timeout + 10 seconds (${rest.controller.authcard.request.timeout.ms})
terminal.server.client.response.map.expiration.ms = #{(60000 * 2 + 60000 * 4 + 30000 + 1000) + 10000}
# if thread count is 0, netty will use availableProcessors * 2
terminal.server.netty.main.group.threads = 0
terminal.server.netty.worker.group.threads = 0
terminal.server.netty.so.backlog = 10000
terminal.server.netty.max.frame.length = #{1024 * 10}
terminal.server.netty.reader.idle.timeout.seconds = #{6 * 60}
# controls how long to wait for a CONNECT message from a new connection
terminal.server.netty.connect.timeout.ms = 1000
panpad.terminal.server.max.message.length = 1000
bolt.terminal.server.max.message.length = #{1024 * 10}
terminal.server.fd.message.length = ${panpad.terminal.server.max.message.length}
terminal.server.download.max.retries = 3
# 6 field cron expression in UTC: second, minute, hour, day, month, weekday
# e.g. '0 0 7 ? * SAT,SUN' fires at 2:00 AM EST on Saturdays and Sundays
terminal.server.reconnect.default.cron.expression = 0 0 7 * * *
# ISO_8601 duration defining the default length of the reconnect window
# e.g. PT1H30M for 1 hour 30 minutes
terminal.server.reconnect.default.duration = PT1H
# controls how many connections are disconnected at the same time
terminal.server.reconnect.batch.size = 10
# controls how long the process waits before closing another set of connections
terminal.server.reconnect.batch.sleep.interval.ms = #{60000 * 2}
terminal.server.reconnect.sleep.interval.ms = #{60000 * 1}
terminal.service.threads = 20
# Changing terminal service request timeouts below may require updating other dependent timeout props in this file
terminal.service.default.request.timeout.ms = 5000
terminal.service.manual.input.request.timeout.ms = #{60000 * 2}
terminal.service.cancel.request.timeout.ms = 30000
terminal.service.print.receipt.request.timeout.ms = ${terminal.service.default.request.timeout.ms}
terminal.service.restart.terminal.request.timeout.ms = 5000
terminal.service.sale.request.timeout.ms = #{60000 * 4}
terminal.service.manual.refund.request.timeout.ms = #{60000 * 4}
terminal.service.refund.payment.request.timeout.ms = #{60000 * 4}
terminal.service.void.payment.refund.request.timeout.ms = #{60000 * 4}
terminal.service.void.payment.request.timeout.ms = #{60000 * 4}
terminal.service.reverse.payment.request.timeout.ms = #{60000 * 4}
terminal.service.graceful.shutdown.sleep.interval.ms = 10000
terminal.service.void.request.timeout.ms = 5000
terminal.service.socket.ping.flush.ping.protocol.bolt.enabled = true
terminal.service.socket.ping.flush.ping.protocol.panpad.enabled = true
# max time to wait for terminals to gracefully disconnect at shutdown before forcibly closing all remaining connections
terminal.service.graceful.shutdown.timeout.ms = #{60000 * 4}
# should be same as maximum timeout on rest API
terminal.service.cancellable.task.expiration.ms = ${rest.controller.authcard.request.timeout.ms}
terminal.connect.token.expiration.ms = 60000
terminal.connect.token.display.text = Authentication Token:\n##token##
terminal.server.ftcheck.minimum.pp.version = 01060017
terminal.server.styleprops.minimum.pp.version = 01060017
terminal.server.confirm.minimum.pp.version = 01050203
terminal.server.contactless.minimum.pp.version = 01060033
terminal.server.tip.minimum.pp.version = 1060108
terminal.server.retrieve.log.minimum.pp.version = 02000000
terminal.server.capk.file.download.minimum.pp.version = 02010000
terminal.server.surcharge.minimum.pp.version = 02010000
terminal.server.surcharge.minimum.clover.version = 01090900
terminal.server.readcard.nfc.emvpos.values = 07,82
# whether to send a 'select' command to the terminal for credit/debit selection during composite tasks
terminal.server.composite.task.credit.debit.selection.enabled = false
bolt.terminal.server.message.maskedFields = authKey,encryptedTrack1,encryptedTrack2,encryptedPan,encryptedPin,emvTags,encryptedCvv
panpad.terminal.server.message.maskedFields = authkey,t1,t2,pan,pin,emv

terminal.service.xff.request.operations.whitelist = authterminal,get_terminal_props,get_terminal_download,log
# clear Display skip response's default value is true as we want to let it run wait without waiting for its response
terminal.service.clear.display.skip.response.readcard.enabled = false
terminal.service.shutdown.immediate=true
terminal.service.shutdown.immediate.shutdownBatchCount=10

#####################################################
# Tomcat
tomcat.connector.protocol = org.apache.coyote.http11.Http11NioProtocol
tomcat.connector.max.connections = -1
tomcat.connector.max.threads = 200
# set to 1 to disable HTTP keep-alive and pipelining (see https://tomcat.apache.org/tomcat-8.0-doc/config/http.html)
tomcat.connector.max.keep-alive.requests = 1
# 'async.timeout' value should be > the maximum 'rest.controller.*.request.timeout.ms' value
tomcat.connector.async.timeout.ms = #{(60000 * 2 + 60000 * 4 + 30000 + 1000) + 10000}
server.tomcat.basedir=target/tomcat

#####################################################
# CardSecure
card.secure.port = 443
card.secure.ssl = true
card.secure.client.verbose.logging = false
card.secure.read.timeout.ms = 5000
card.secure.connect.timeout.ms = 1000
card.secure.health.check.enabled = true
card.secure.connection.pool.max.size = 10
card.secure.connection.keepAliveSeconds = 10
# do not include 'devicedata' field as it is masked separately by CardSecureClient
card.secure.tokenize.request.maskedFields = account
card.secure.client.http2Enabled = true
card.secure.client.http2PoolMaxSize = 5
card.secure.client.http2ConnectTimeoutMs = 1000
card.secure.client.http2KeepaliveTimeoutSeconds = 20

#####################################################
# TMS
tms.host = tms-qa.cardconnect.com
tms.port = 443
tms.ssl = true
tms.relative.path = terminal
tms.client.verbose.logging = false
tms.read.timeout.ms = 5000
tms.connect.timeout.ms = 1000
tms.keepalive.timeout.seconds = 20
tms.health.check.enabled = true
tms.cache.apikey.max.size = 10000
tms.cache.apikey.expiration.ms = #{60000 * 30}
tms.cache.hsn.max.size = 10000
tms.cache.hsn.expiration.ms = #{60000 * 30}
tms.download.thread.pool.size = 20
tms.download.attempts.max = 20
tms.download.attempts.enabled = false
tms.connection.pool.max.size = 10
tms.http2Enabled = true
tms.http2PoolMaxSize = 5
tms.http2ConnectTimeoutMs = 1000
tms.http2KeepaliveTimeoutSeconds = 20

#####################################################
# Gateway Terminal Service
gateway.terminal.service.port = 443
gateway.terminal.service.ssl = true
gateway.terminal.service.relative.path = cardconnect/terminal
gateway.terminal.service.client.verbose.logging = false
gateway.terminal.service.read.timeout.ms = 15000
gateway.terminal.service.connect.timeout.ms = 2500
gateway.terminal.service.keepalive.timeout.seconds = 20
gateway.terminal.service.connection.pool.max.size = 200
gateway.terminal.service.health.check.enabled = true
gateway.terminal.service.message.maskedFields = cvv2,track,pan,pin,emv
# should be a very small value to avoid waiting for a response, since we don't require one
gateway.terminal.service.sigcap.timeout.ms = 5000
gateway.terminal.service.timeout.reversal.enabled = true
gateway.terminal.service.timeout.reversal.inquire.timeout.ms = 3000
gateway.terminal.service.inquire.merchant.timeout.ms = 10000
# below 2 properties are used for gateway terminal timeout health indicator check
gateway.terminal.service.inquire.merchant.health.indicator.authKey = aDlzqEdIK1EWFl6NqlEV2I1Iz0RghqRNdvFu19fWe2s=
gateway.terminal.service.inquire.merchant.health.indicator.site = qa
# should be a very small value to avoid waiting for a response, since we don't require one
gateway.terminal.service.timeout.reversal.void.timeout.ms = 100
gateway.terminal.service.inquire.merchant.timeout.ms = 10000
gateway.terminal.service.http2Enabled = true
gateway.terminal.service.http2PoolMaxSize = 5
gateway.terminal.service.http2ConnectTimeoutMs = 1000
gateway.terminal.service.http2KeepaliveTimeoutSeconds = 20
gateway.terminal.service.inquirebyorderid.merchantlookup.on = true
#####################################################
# MerchantPropertiesService
gateway.domain.name = cardconnect.com
gateway.uat.url = false

#####################################################
# XDC service
# configuration for making cross-data center (XDC) API requests between remote Bolt DCs
current.data.center = LOCAL1
data.center.hostnames = LOCAL1:localhost:8082,LOCAL2:localhost:8182
# determines whether or not the application will operate with cross-DC awareness
xdc.service.enabled = true
# determines whether the application should proactively attempt to update stale data in Couchbase
xdc.service.connection.details.synchronization.enabled = true
#####################################################
# Bolt XDC REST API Client
bolt.xdc.client.ssl = false
bolt.xdc.client.verbose.logging = false
bolt.xdc.client.connect.timeout.ms = 1000
bolt.xdc.client.read.timeout.ms = 5000
bolt.xdc.client.connection.pool.max.size = 10
bolt.xdc.client.keepalive.timeout.seconds = 20
bolt.xdc.client.http2Enabled = true
bolt.xdc.client.http2PoolMaxSize = 5
bolt.xdc.client.http2ConnectTimeoutMs = 1000
bolt.xdc.client.http2KeepaliveTimeoutSeconds = 20
bolt.xdc.update.to.hazelcast.enabled = true

#####################################################
# Logging
logging.console.enabled = true
logging.file.enabled = false
logging.file.name = bolt.log
logging.file.path = target
# total days of history
logging.file.max.history = 30
# cap on size for all log files
logging.file.total.size.cap = 500MB
logging.logstash.enabled = false
logging.logstash.file = bolt-json.log
logging.logstash.path = target
logging.logstash.max.history = 30
logging.logstash.total.size.cap = 500MB
logging.access.enabled = false
logging.access.file = bolt-access.log
logging.access.path = target
logging.access.max.history = 30
logging.access.total.size.cap = 500MB
logging.level.com.cardconnect.bolt = TRACE
logging.level.org.springframework.web = INFO
logging.level.org.springframework.amqp.rabbit = INFO
logging.level.com.hazelcast = INFO
logging.level.io.netty = INFO
logging.level.org.hibernate = INFO
logging.level.com.zaxxer.hikari = INFO
logging.level.com.couchbase = INFO
logging.level.root = INFO

#####################################################
# Management
management.server.port = 8081
management.security.user.name = management
management.security.user.password = management
management.endpoints.web.exposure.include = health, info, env, shutdown, setLive, isActiveDataCenter, connections, offlineBatchProcessor, terminals, tmsClient, merchantProps, httptrace, logfile, requestQueueMap, loggers, metrics
management.endpoint.health.enabled = true
management.endpoint.health.show-details = always
management.endpoint.info.enabled = true
management.endpoint.env.enabled = true
management.endpoint.shutdown.enabled = true
management.endpoint.setLive.enabled = true
management.endpoint.isActiveDataCenter.enabled = true
management.endpoint.connections.enabled = true
management.endpoint.offlineBatchProcessor.enabled = true
management.endpoint.terminals.enabled = true
management.endpoint.tmsClient.enabled = true
management.endpoint.requestQueueMap.enabled = true
management.endpoints.enabled-by-default = false
management.endpoint.httptrace.enabled = true
management.endpoint.logfile.enabled = true
management.endpoint.loggers.enabled = true
management.endpoint.logfile.external-file = ${logging.file.path}/${logging.file.name}
management.health.filedescriptor.usage.threshold.percent = 90
management.health.diskspace.threshold = 104857600
management.health.hazelcast.queue.usage.threshold = 20
management.health.end.to.end.enabled = true
management.health.end.to.end.hsn = TMCSCSMOKETESTDEV
management.health.end.to.end.mid = 888888888888
management.health.terminal.server.used.memory.threshold = #{1024 * 1024 * 1024}
management.terminals.endpoint.default.timeout.ms = 30000
management.terminals.endpoint.retrieve.log.timeout.ms = 180000
# must be sufficiently longer than terminal.service.restart.terminal.request.timeout.ms
management.terminals.endpoint.restart.terminal.timeout.ms = 10000
# time to wait for terminal to process API commands before sending restart
management.terminals.endpoint.restart.terminal.wait.max.ms = 30000

#####################################################
# Metrics
metric.logging.file.enabled = true
metric.logging.micrometer.file.name = bolt-micrometer-metrics.log
metric.logging.micrometer.level = INFO
metric.logging.file.path = target
# total days of history
metric.logging.file.max.history = 30
# cap on size for all log files
metric.logging.file.total.size.cap = 500MB

metric.rabbitmq.publisher.enabled = true
metric.rabbitmq.publisher.host = localhost
metric.rabbitmq.publisher.port = 5672
# for the default exchange, metric.rabbitmq.publisher.exchange should be blank
metric.rabbitmq.publisher.exchange = telegraf
# when using the default exchange, this value should be the same as the queue name
metric.rabbitmq.publisher.routing.key = 10
metric.rabbitmq.publisher.vhost = local
metric.rabbitmq.publisher.username = user
metric.rabbitmq.publisher.password = pass

#####################################################
# Micrometer metrics
management.metrics.export.cc.influx.transport=logging
management.metrics.export.cc.influx.logger-name=micrometerLogger
management.metrics.export.cc.influx.step=10s
management.metrics.export.cc.influx.batch-size=5000
management.metrics.export.cc.influx.num-threads=2
management.metrics.export.cc.influx.rabbit-mq.exchange=exch.telegraf
management.metrics.export.cc.influx.rabbit-mq.routing-key=10
management.metrics.export.cc.influx.rabbit-mq.virtual-host=local
management.metrics.export.cc.influx.rabbit-mq.username=user
management.metrics.export.cc.influx.rabbit-mq.password=pass
management.metrics.export.cc.influx.rabbit-mq.addresses=amqp://localhost:5672
management.metrics.export.cc.influx.rabbit-mq.health-indicator-enabled = false

management.statsd.metrics.export.enabled = true
management.statsd.metrics.export.flavor = telegraf
management.statsd.metrics.export.port=8125

management.metrics.tags.datacenter = KOP
management.metrics.tags.influxdb_database = test
management.metrics.tags.application = bolt
management.metrics.tags.appgroup = bolt
management.metrics.tags.environment = local
management.metrics.tags.host = local
cc.metrics.event.measurement-count=count
cc.metrics.event.measurement-time-elapsed=elapsed.time
# exclusions (default MM metrics for now)
management.metrics.enable.jvm = false
management.metrics.enable.system = false
management.metrics.enable.logback = false
management.metrics.enable.rabbitmq = false
management.metrics.enable.hikaricp = false
management.metrics.enable.tomcat = false
management.metrics.enable.jdbc = false
management.metrics.enable.process = false
management.metrics.enable.spring = false

#####################################################
# RabbitMQ
#remove 3.3.10 release
spring.rabbitmq.addresses = localhost:5672
spring.rabbitmq.virtual-host = local
spring.rabbitmq.username = user
spring.rabbitmq.password = pass
spring.rabbitmq.ssl.enabled = false

#####################################################
# datasource & Tomcat JDBC Connection pool config
#
# Ref: https://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html#System_Properties
spring.datasource.url = jdbc:mysql://localhost:3306/bolt?characterEncoding=UTF-8&useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=America/New_York
spring.datasource.username = cconnect
spring.datasource.password = cconnect123

# The initial number of connections that are created when the pool is started.
spring.datasource.tomcat.initialSize=5

# The minimum number of established connections that should be kept in the pool
# at all times.
spring.datasource.tomcat.minIdle=0

# The maximum number of active connections that can be allocated from this pool
# at the same time.
spring.datasource.tomcat.maxActive=10

# The maximum number of connections that should be kept in the pool at all times.
spring.datasource.tomcat.maxIdle=10

# The indication of whether objects will be validated before being borrowed
# from the pool.
spring.datasource.tomcat.testOnBorrow=true 

# The indication of whether objects will be validated when a connection is
# first created.
spring.datasource.tomcat.testOnConnect=false 

# The indication of whether objects will be validated before being returned to
# the pool.
spring.datasource.tomcat.testOnReturn=false 

# The indication of whether objects will be validated by the idle object evictor
# (if any). If an object fails to validate, it will be dropped from the pool.
# The default value is false and this property has to be set in order for the
# pool cleaner/test thread is to run
spring.datasource.tomcat.testWhileIdle=true

# The SQL query that will be used to validate connections from this pool before
# returning them to the caller.  If specified, this query does not have to
# return any data, it just can't throw a SQLException.
spring.datasource.tomcat.validationQuery=/* ping */ SELECT 1

# (int) The timeout in seconds before a connection validation queries fail.
# This works by calling java.sql.Statement.setQueryTimeout(seconds) on the
# statement that executes the validationQuery.
# The pool itself doesn't timeout the query, it is still up to the JDBC driver
# to enforce query timeouts.
# A value less than or equal to zero will disable this feature.
# The default value is -1.
spring.datasource.tomcat.validationQueryTimeout=5

# (int) The number of milliseconds to sleep between runs of the idle connection
# validation/cleaner thread. This value should not be set under 1 second.
# It dictates how often we check for idle, abandoned connections, and how
# often we validate idle connections. The default value is 5000 (5 seconds).
spring.datasource.tomcat.timeBetweenEvictionRunsMillis=20000

# (boolean) Flag to remove abandoned connections if they exceed the
# removeAbandonedTimeout. If set to true a connection is considered abandoned
# and eligible for removal if it has been in use longer than the
# removeAbandonedTimeout Setting this to true can recover db connections from
# applications that fail to close a connection. See also logAbandoned.
# The default value is false.
spring.datasource.tomcat.removeAbandoned=true

# (int) Timeout in seconds before an abandoned(in use) connection can be
# removed. The default value is 60 (60 seconds). The value should be set to the
# longest running query your applications might have.
spring.datasource.tomcat.removeAbandonedTimeout=60

# (boolean) Flag to remove abandoned connections if they exceed the
# removeAbandonedTimeout. If set to true a connection is considered abandoned
# and eligible for removal if it has been in use longer than the
# removeAbandonedTimeout Setting this to true can recover db connections from
# applications that fail to close a connection. See also logAbandoned
# The default value is false.
spring.datasource.tomcat.logAbandoned = true

# The minimum amount of time an object may sit idle in the pool before it is
# eligible for eviction. The default value is 60000 (60 seconds).
spring.datasource.tomcat.minEvictableIdleTimeMillis = 60000

# Explicitly register an OpenEntityManagerInViewInterceptor to avoid warnings
spring.jpa.open-in-view = true

# This is required for long-running management APIs
# Should generally match the tomcat.connector.async.timeout.ms value (does not support SpEL expressions)
spring.mvc.async.request-timeout = 401000

#####################################################
# JPA/Hibernate
spring.jpa.hibernate.ddl-auto = none

#####################################################
# Offline Batch Processing
offline.batch.process.period.seconds = #{60 * 5}
offline.batch.process.auth.throughput.limit = 20
offline.batch.process.batch.size = 50
offline.batch.process.bolt.on.clover.enabled = true

# NEVER TURN THIS ON
spring.main.allow-circular-references = false
spring.messages.basename=messages
